/**
 * Main class for running tests.
 * 
 * @author Prateeth Reddy Chagari (chagari2@illinois.edu)
 */

import java.io.*;
import java.util.Scanner;
import java.util.Properties;

public class TestClient {
    
    /**
    *  server addresses
    */
    static String addresses[] = null;
    /** 
     *  VM log IDs
    */
    static String vmIds[] = null;
    /**
     *  grep patterns to be sent to each server
     */
    static String vm_patterns[] = null;

    /**
     * stores the content of each output file generated by grep
     */
    static String output = "";
    /**
     *  stores output after parsing from property files
     */
    static String split_output[] = null;

    /**
     *  input streams to access properties file
     */
    static InputStream inputTestProps;
    static  InputStream inputServerProps;

    /**
    * retrieves properties from test.properties file
    */ 
    static Properties testProps;
    static Properties serverProps;

    static int pass = 0, count, vm_count;

    /**
     * default constructor for TestClient.
     * 
     */
    public TestClient() throws IOException {
        inputTestProps = new FileInputStream("test.properties");
        testProps = new Properties();
        inputServerProps = new FileInputStream("server_parameters.properties");
        serverProps = new Properties();
    }
    public static void main(String args[]) throws IOException {

        TestClient test = new TestClient();
        // loads properties from respective property files
        testProps.load(inputTestProps);
        serverProps.load(inputServerProps);
        
        // calls the log generator method and returns number of log files generated (one for each server)
        int pass = log_generator();

        // run the grep command for frequent pattern
        String frequentPattern = "sdfsdfsdfsd";
        run_server(pass, frequentPattern, "frequent pattern", false);

        // run the grep command for infrequent pattern
        // String infrequentPattern = "sdasdasd";
        // run_server(pass, infrequentPattern, "infrequent pattern", false);

        // run the grep command for regex pattern
        // String regexPattern = "Dasds";
        // run_server(pass, regexPattern, "regex", false);

        // run the grep command to return just count for frequent pattern
        String patternCount = "-c sdfsdfsdfsd";
        run_server(pass, patternCount, "frequent pattern for count", true);

        System.out.println("All tests passed");
    }

    /**
     * Method to generate a log file in each server
     */
    public static int log_generator() throws IOException {

        try {
            // get the corresponding property values from the .properties files
            addresses = serverProps.getProperty("IP_address").split(",");
            vmIds = serverProps.getProperty("VM_ID").split(",");
        } 
        catch (Exception e) {
            System.out.println(e);
        }

        // variable to store name of each logfile whose values are obtained from .properties file
        String[] logfile = new String[addresses.length];
        for (int i = 0; i < addresses.length; i++) {
            logfile[i] = vmIds[i];
            // invoke Client.main() thread that invokes each server with (server address, test pattern, logfileID, port)
            Client client = new Client(addresses[i], testProps.getProperty(addresses[i]), logfile[i], 5500);
            client.create_thread();
        }

        // wait for all client threads to finish execution
        try {
            Thread.sleep(20000);
        }
        catch (Exception e){
            System.out.println("Thread timed out while running test");
            System.exit(1);
        }

        // checks if the expected number of files have been generated
        for (int i=0; i < logfile.length; i++) {
            try {
                BufferedReader br = new BufferedReader(new FileReader(("output_"+logfile[i])));
                output = br.readLine();

                if(output.equalsIgnoreCase("Log file generated"))
                    pass++;
            }
            catch(FileNotFoundException e) {
                System.out.println("The logfile generation for "+ logfile[i]+" did not succeed");
                System.out.println("Test failed");
                System.exit(1);
            }
        }
        return pass;
    }
        
     /**
     * Method to run each server 
     * @param pass count indicating number of logfiles successfully created
     * @param clientInput input against which grep is tested
     * @param pattern indicates whether input is frequent pattern, infrequent pattern or regex(only for printing)
     * @param checkCount boolean to indicate if the server returns only line count
     */
    public static void run_server(int pass, String clientInput, String pattern, Boolean checkCount) throws IOException {
        int pass_local = pass;
        String[] logfile = new String[addresses.length];

        /**
        * checks if number of server addresses provided in test.properties 
        * matches number of logfiles generated
        *  */
        if(pass_local == addresses.length) {
            
            // generate a client thread each to talk to one server
            for (int i = 0; i < addresses.length; i++) {
                logfile[i] = vmIds[i];
                Client client = new Client(addresses[i], clientInput, logfile[i], 5000);
                client.create_thread();
            }
            // wait for all threads to complete execution
            try {
                Thread.sleep(20000);
            }
            catch (Exception e){
                System.out.println("Thread timed out while running test on "+pattern);
                System.exit(1);
            }

            pass_local = 0;
            for (int i=0; i < addresses.length; i++) {
                try {
                        // read lines from newly generated local log files
                        BufferedReader br = new BufferedReader(new FileReader("output_"+logfile[i]));
                        String splitter;
                        // if server returns only one line indicating linecount, read firstline 
                        if(checkCount) 
                            output = br.readLine();

                        // if server returns all the expected logs, read last line containing linecount
                        else {
                            String temp;
                            while ((temp = br.readLine()) != null) {
                                output = temp;
                            }
                        }
                        System.out.println(output);

                        // obtain linecount from output which is in the form <fileName> <linecount>
                        split_output = output.split(" ");

                        // line count obtained from server
                        count = Integer.parseInt(split_output[1]);

                        // extracts the VM patterns provided in test.properties for each server address
                        vm_patterns = testProps.getProperty(addresses[i]).split(",");

                        // further extracts the line count provided for each pattern (in test.properties) 
                        vm_count = Integer.parseInt((vm_patterns[i].split("="))[1]);

                        // compares if returned count matched expected line count
                        if (count != vm_count) {
                            System.out.println("Line count does not match. Test failed.");
                            System.exit(1);
                        }
                        else {
                            pass_local++;
                        }
                    }
                catch(Exception e) {
                    System.out.println("Test failed while running tests for "+pattern);
                    System.exit(1);
                }
            }
        } 
        System.out.println("Test passed for "+pattern);  
    }
}